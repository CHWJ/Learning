### 概述
> 原型（Prototype）模式，使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。注意，通过克隆方法所创建的对象时全新的对象。

### 结构图
- ![原型](/resource/image/designPattern/prototype.png)
- 3 个角色
    - Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。
    - ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象
    - Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。

### 复制
- 浅复制 复制一个对象的时候，仅仅复制原始对象中所有的**非静态类型成员**和所有的**引用类型成员**的引用。（新对象和原对象将共享所有引用类型成员的实际对象，**在新对象中对引用类型的字段值做修改会影响到原对象本身**）
    - 实现
        - 浅表副本[MemberwiseClone,C#]
- 深复制 复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的**实际对象**，对于新对象的修改，不会影响到原对象本身。
    - 实现
        - 借助序列化 类定义上面加上可序列化的标签[Serializable,C#]

### 主要优点
- 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有的实例可以提高新实例的创建效率。
- 可以使用深复制的方式保存对象的状态。将对象复制一份并将其状态保存起来，以便于在使用的时候使用，比如恢复到某一个历史状态，可以辅助实现撤销操作。

### 主要缺点
- 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。
- 为了支持深复制，当对象之间存在多重嵌套引用关系时，每一层对象都必须支持深复制，实现起来可能比较麻烦。

### 适用场景
- 创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或者网络资源），新的对象可以通过原型模式对已有对象进行复制来获得。如果是相似对象，则可以对其成员变量稍作修改。

### 引用
- [周旭龙 - 设计模式的征途—5.原型（Prototype）模式](https://www.cnblogs.com/edisonchou/p/6798743.html)