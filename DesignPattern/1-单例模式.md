### 概述
- 在单例类的内部实现只生成一个实例，同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例
- 为了防止在外部对单例类实例化，它的构造函数被设为private
- 在单例类的内部定义了一个Singleton类型的静态对象，作为提供外部共享的唯一实例

### 3 个要点
- 某个类只能有一个实例
- 它必须自行创建这个实例
- 它必须自行向整个系统提供这个实例

### 3 种实现方式
- 饿汉式（eager）
    - 定义
        - 不管一个人想不想吃东西都把吃的先买好，如同饿怕了一样。   
    - C#实现
        - C#的语法中有一个函数能够确保只调用一次，那就是静态构造函数。由于C#是在调用静态构造函数时初始化静态变量，.NET运行时（CLR）能够确保只调用一次静态构造函数，这样我们就能够保证只初始化一次instance。但是，由于在C#中调用静态构造函数的时机不是由程序员掌控的，而是当.NET运行时发现第一次使用该类型的时候自动调用该类型的静态构造函数，这样会过早地创建实例，从而降低内存的使用效率。此外，静态构造函数由 .NET Framework 负责执行初始化，我们对对实例化机制的控制权也相对较少。
    - 缺点
        - 浪费内存空间。如果该实例从始至终都没被使用过，则会造成内存浪费。
- 懒汉式（lazy）
    - 定义
        - 一个人懒的饿到不行了才去吃东西。
    - C#实现
        - 使用关键字lock/Moniter.Enter+Exit等
    - 双重检查锁定（Double-Check Locking）
    - 缺点
        - 线程安全控制繁琐，而且性能受影响
- 静态内部类单例
    ``` c#
    public class LoadBalancer
    {
        ......

        // 公共静态成员方法，返回唯一实例
        public static LoadBalancer GetLoadBalancer()
        {
            return Nested.instance;
        }

        // 使用内部类+静态构造函数实现延迟初始化
        class Nested
        {
            static Nested() { }
            internal static readonly LoadBalancer instance = new LoadBalancer();
        }

        ......
    }
    ```
    该实现方法在内部定义了一个私有类型Nested。当第一次用到这个嵌套类型的时候，会调用静态构造函数创建LoadBalancer的实例instance。如果我们不调用属性LoadBalancer.GetLoadBalancer()，那么就不会触发.NET运行时（CLR）调用Nested，也就不会创建实例，因此也就保证了按需创建实例（或延迟初始化）。可见，此方法既可以实现延迟加载，又可以保证线程安全，不影响系统性能。但其缺点是与具体编程语言本身的特性相关，有一些面向对象的编程语言并不支持此种方式。

### 不适宜情景
- 不要实现 ICloneable 接口或继承自其相关的子类，否则客户程序可以跳过已经隐蔽起来的类构造函数
- 不能对期望具有 Singleton 特性的类声明 SerializableAttribute 特性，因为序列化事实上完成了 Singleton 对象的复制和重现

### 适用场景
- 系统只需要一个实例对象。例如：系统要求提供一个唯一的序列号生成器或者资源管理器，又或者需要考虑资源消耗太大而只允许创建一个对象。
- 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。

### 引用
- [周旭龙 - 设计模式的征途—1.单例（Singleton）模式](https://www.cnblogs.com/edisonchou/p/6618503.html)